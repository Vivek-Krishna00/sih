<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Final Data Annihilation Protocol</title>
    <!-- Use Tailwind CSS for modern, responsive styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a;
        }
        #dropZone {
            border-width: 3px;
            border-style: dashed;
            border-color: #3b82f6; /* Tailwind blue-500 */
            transition: border-color 0.3s, background-color 0.3s;
        }
        #dropZone.hover {
            border-color: #60a5fa; /* Tailwind blue-400 */
            background-color: #1e293b; /* Tailwind slate-800 */
        }
        .message-box {
            position: fixed;
            top: 2rem;
            left: 50%;
            transform: translateX(-50%);
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            background-color: #333;
            color: #fff;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            z-index: 1000;
        }
        .message-box.show {
            opacity: 1;
        }
        .glitch-text {
            font-family: 'Courier New', Courier, monospace;
            text-shadow: 1px 1px 0px #ff00ff, -1px -1px 0px #00ffff;
            animation: glitch 1s infinite;
        }
        @keyframes glitch {
            0% { text-shadow: 1px 1px 0px #ff00ff, -1px -1px 0px #00ffff; }
            20% { text-shadow: -1px -1px 0px #ff00ff, 1px 1px 0px #00ffff; }
            40% { text-shadow: 1px -1px 0px #ff00ff, -1px 1px 0px #00ffff; }
            60% { text-shadow: -1px 1px 0px #ff00ff, 1px -1px 0px #00ffff; }
            80% { text-shadow: 1px 1px 0px #ff00ff, -1px -1px 0px #00ffff; }
            100% { text-shadow: -1px -1px 0px #ff00ff, 1px -1px 0px #00ffff; }
        }
        #protocolLog {
            background-color: #000;
            border: 2px solid #3b82f6;
            color: #0f0;
            font-family: 'Courier New', Courier, monospace;
            padding: 1rem;
            border-radius: 0.75rem;
            height: 15rem;
            overflow-y: auto;
            white-space: pre-wrap;
            scrollbar-width: thin;
            scrollbar-color: #3b82f6 #000;
        }
        #protocolLog::-webkit-scrollbar {
            width: 8px;
        }
        #protocolLog::-webkit-scrollbar-track {
            background: #000;
        }
        #protocolLog::-webkit-scrollbar-thumb {
            background-color: #3b82f6;
            border-radius: 4px;
        }
        #wipedDataContainer {
            min-height: 15rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #dataCanvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">

    <!-- Main Container -->
    <div class="bg-gray-900 p-8 rounded-2xl shadow-2xl max-w-4xl w-full text-white">
        <h1 class="text-4xl font-bold mb-2 text-center text-white glitch-text">Final Data Annihilation Protocol</h1>
        <p class="text-gray-400 mb-6 text-sm text-center">
            This tool simulates an ultimate, irreversible data destruction protocol for total security.
        </p>
        <div class="text-sm font-bold text-red-400 mb-4 rounded-xl border border-red-400 p-2 text-center">
            DISCLAIMER: This is a simulation. No files on your local computer are modified or deleted.
        </div>
        
        <!-- Four-Step Protocol Section -->
        <div class="bg-gray-800 p-6 rounded-xl mb-8">
            <h2 class="text-2xl font-semibold mb-4 text-blue-400 text-center">Client Authorization Process</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                <div class="bg-gray-700 p-4 rounded-lg">
                    <h3 class="text-xl font-bold text-green-400">Step 1: Consultation</h3>
                    <p class="text-gray-300 text-sm mt-1">Define the exact scope of data to be destroyed to ensure no misunderstandings.</p>
                </div>
                <div class="bg-gray-700 p-4 rounded-lg">
                    <h3 class="text-xl font-bold text-green-400">Step 2: Irreversibility</h3>
                    <p class="text-gray-300 text-sm mt-1">Acknowledge that once the protocol begins, the data is permanently wiped and cannot be recovered.</p>
                </div>
                <div class="bg-gray-700 p-4 rounded-lg">
                    <h3 class="text-xl font-bold text-green-400">Step 3: Formal Authorization</h3>
                    <p class="text-gray-300 text-sm mt-1">Obtain formal, written permission from the customer to proceed with the irreversible process.</p>
                </div>
                <div class="bg-gray-700 p-4 rounded-lg">
                    <h3 class="text-xl font-bold text-green-400">Step 4: Execution & Certification</h3>
                    <p class="text-gray-300 text-sm mt-1">Generate a unique token and a PDF certificate as a verifiable record of the completed annihilation.</p>
                </div>
            </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8">
            <!-- Wipe Section -->
            <div class="bg-gray-800 p-6 rounded-xl">
                <h2 class="text-2xl font-semibold mb-4 text-blue-400">1. Wipe a File</h2>
                
                <div class="mb-4">
                    <p class="text-sm text-gray-300">User ID: <span id="userIdDisplay" class="font-mono text-blue-400">Loading...</span></p>
                </div>
                <button id="startButton" class="w-full py-2 px-4 bg-green-600 hover:bg-green-700 text-white font-bold rounded-xl transition-colors duration-200 shadow-lg" disabled>
                    Awaiting Connection
                </button>

                <!-- Drop Zone -->
                <div id="dropZone" class="flex flex-col items-center justify-center p-8 rounded-xl cursor-not-allowed transition-all mt-4 opacity-50">
                    <svg class="w-16 h-16 text-blue-500 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-4-4v0a4 4 0 014-4h4l.6-1.6a2 2 0 011.8-.9h4.8c1.1 0 2 .9 2 2v10c0 1.1-.9 2-2 2H7a4 4 0 01-4-4z"></path>
                    </svg>
                    <p id="dropText" class="text-gray-300 text-center">Drag & Drop **multiple** files here, or click to select.</p>
                    <input type="file" id="fileInput" class="hidden" multiple>
                </div>
                
                <!-- Progress Bar -->
                <div id="progressBarContainer" class="w-full bg-gray-600 rounded-full mt-4 h-2 hidden">
                    <div id="progressBar" class="bg-blue-500 h-2 rounded-full transition-all duration-300 ease-linear" style="width: 0%;"></div>
                </div>

                <!-- Protocol Log -->
                <div id="protocolLogContainer" class="mt-4">
                    <pre id="protocolLog" class="text-sm">Awaiting connection to Firebase...</pre>
                </div>
            </div>

            <!-- Verification Section -->
            <div class="bg-gray-800 p-6 rounded-xl">
                <h2 class="text-2xl font-semibold mb-4 text-blue-400">2. Verify Certification</h2>
                <p class="text-gray-400 mb-4 text-sm">Paste a token to verify a file's certification.</p>
                <div class="mb-4">
                    <input type="text" id="tokenInput" placeholder="Enter token here" class="w-full p-2 rounded-md bg-gray-700 text-white border border-gray-600 focus:outline-none focus:border-blue-500">
                </div>
                <button id="verifyButton" class="w-full py-2 px-4 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-xl transition-colors duration-200 shadow-lg">
                    Verify Token
                </button>
                <div id="verificationResult" class="mt-4 hidden p-4 rounded-xl">
                    <p id="verificationStatus" class="font-semibold"></p>
                    <div id="verificationDetails" class="text-sm mt-2"></div>
                </div>
            </div>

            <!-- Visualization Section -->
            <div class="bg-gray-800 p-6 rounded-xl">
                <h2 class="text-2xl font-semibold mb-4 text-blue-400">3. Visualize Wiped Data</h2>
                <p class="text-gray-400 mb-4 text-sm">
                    A 3D rendering of the final data obliteration.
                </p>
                <div id="wipedDataContainer" class="p-4 bg-gray-700 rounded-xl max-h-60 mb-4">
                    <canvas id="dataCanvas" class="w-full h-full"></canvas>
                </div>
                <div>
                    <button id="visualizeButton" class="w-full py-2 px-4 bg-purple-600 hover:bg-purple-700 text-white font-bold rounded-xl transition-colors duration-200 shadow-lg" disabled>
                        Simulate Wiped Data
                    </button>
                </div>
            </div>
            
            <!-- Annihilation Section - New Step -->
            <div class="bg-gray-800 p-6 rounded-xl">
                <h2 class="text-2xl font-semibold mb-4 text-blue-400">4. Authorize Final Purge</h2>
                <p class="text-gray-400 mb-4 text-sm">
                    This is the final step. By authorizing this action, you are giving final
                    permission to permanently delete the certification record.
                </p>
                <div class="bg-yellow-900 text-yellow-300 p-4 rounded-md mb-4">
                    <span class="font-bold">WARNING:</span> This action is <span class="text-red-400 font-bold">irreversible.</span> The token will become invalid,
                    and verification will no longer be possible.
                </div>
                <div class="flex items-center mb-4">
                    <input type="checkbox" id="consentCheckbox" class="form-checkbox h-5 w-5 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500">
                    <label for="consentCheckbox" class="ml-2 text-sm text-gray-300">I understand and wish to proceed.</label>
                </div>
                <button id="authorizeAnnihilationButton" class="w-full py-2 px-4 bg-red-600 hover:bg-red-700 text-white font-bold rounded-xl transition-colors duration-200 shadow-lg" disabled>
                    Authorize Annihilation
                </button>
            </div>
        </div>

        <!-- Output Section for Token and Certification -->
        <div id="outputSection" class="hidden bg-gray-700 p-4 rounded-xl text-left mt-8">
            <h3 class="text-xl font-semibold mb-2 text-green-400">Process Complete!</h3>
            <div class="mb-2">
                <h4 class="font-medium text-gray-300">Last File Certified: <span id="certifiedFileName" class="font-bold text-blue-300"></span></h4>
            </div>
            <div class="flex items-center justify-between">
                <div>
                    <h4 class="font-medium text-gray-300">Generated Token</h4>
                    <pre id="tokenText" class="text-lg font-mono text-green-400 overflow-x-auto"></pre>
                </div>
                <button id="copyButton" class="ml-4 p-2 rounded-full bg-blue-600 hover:bg-blue-700 transition-colors duration-200" title="Copy to clipboard">
                    <svg class="w-5 h-5 text-white" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                        <path d="M8 2a2 2 0 00-2 2v2H4a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-2h2a2 2 0 002-2V4a2 2 0 00-2-2H8zm0 2h6v2H8V4zm8 8v4H4V8h12v4z"></path>
                    </svg>
                </button>
            </div>
            <div class="mt-4 flex flex-row gap-2">
                <button id="generatePdfButton" class="w-1/2 py-2 px-4 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-xl transition-colors duration-200 shadow-lg">
                    Generate PDF Certificate
                </button>
                <button id="resetButton" class="w-1/2 py-2 px-4 bg-gray-600 hover:bg-gray-700 text-white font-bold rounded-xl transition-colors duration-200 shadow-lg">
                    Reset
                </button>
            </div>
        </div>
    </div>
    
    <!-- Custom Message Box for copy status -->
    <div id="messageBox" class="message-box">
        Token copied to clipboard!
    </div>
    
    <!-- Library Imports for 3D and Audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <!-- jsPDF Library for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInWithCustomToken, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, getDocs, query, where, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        let userId = null;

        // UI Elements
        const startButton = document.getElementById('startButton');
        const userIdDisplay = document.getElementById('userIdDisplay');
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const outputSection = document.getElementById('outputSection');
        const certifiedFileName = document.getElementById('certifiedFileName');
        const tokenText = document.getElementById('tokenText');
        const copyButton = document.getElementById('copyButton');
        const dropText = document.getElementById('dropText');
        const tokenInput = document.getElementById('tokenInput');
        const verifyButton = document.getElementById('verifyButton');
        const verificationResult = document.getElementById('verificationResult');
        const verificationStatus = document.getElementById('verificationStatus');
        const verificationDetails = document.getElementById('verificationDetails');
        const messageBox = document.getElementById('messageBox');
        const visualizeButton = document.getElementById('visualizeButton');
        const wipedDataContainer = document.getElementById('wipedDataContainer');
        const protocolLog = document.getElementById('protocolLog');
        const dataCanvas = document.getElementById('dataCanvas');
        const progressBarContainer = document.getElementById('progressBarContainer');
        const progressBar = document.getElementById('progressBar');
        const consentCheckbox = document.getElementById('consentCheckbox');
        const authorizeAnnihilationButton = document.getElementById('authorizeAnnihilationButton');
        const resetButton = document.getElementById('resetButton');
        let currentToken = null;
        let is3DAnimating = false;
        let isExploded = false;
        let is3DInitialized = false;

        // Authentication and Firestore setup
        const setupFirebase = async () => {
            try {
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
                userId = auth.currentUser.uid;
                userIdDisplay.textContent = userId;
                console.log("Firebase initialized for user:", userId);

                // Enable the UI now that the user is authenticated
                startButton.textContent = "Start Protocol";
                startButton.disabled = false;
                dropZone.classList.remove('cursor-not-allowed', 'opacity-50');
                dropZone.classList.add('cursor-pointer');
                protocolLog.textContent = `[STATUS] Connection successful. Ready to begin protocol.`;
            } catch (error) {
                console.error("Firebase auth error:", error);
                protocolLog.textContent = `[ERROR] Failed to connect. Check console.`;
            }
        };

        // File drop and input handling
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            if (!dropZone.classList.contains('cursor-not-allowed')) {
                dropZone.classList.add('hover');
            }
        });

        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dropZone.classList.remove('hover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            if (!dropZone.classList.contains('cursor-not-allowed')) {
                dropZone.classList.remove('hover');
                const files = Array.from(e.dataTransfer.files);
                if (files.length > 0) {
                    startWipeProcess(files);
                }
            }
        });

        dropZone.addEventListener('click', () => {
            if (!dropZone.classList.contains('cursor-not-allowed')) {
                fileInput.click();
            }
        });

        fileInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            if (files.length > 0) {
                startWipeProcess(files);
            }
        });
        
        startButton.addEventListener('click', () => {
            // This button now just exists to show that the app is ready.
            // The drop zone itself initiates the process.
            showMessage("Please drag and drop files to start the protocol.");
        });

        // Audio setup with Tone.js
        const typingSynth = new Tone.Synth({
            oscillator: { type: "sine" },
            envelope: {
                attack: 0.005,
                decay: 0.01,
                sustain: 0,
                release: 0.02,
            }
        }).toDestination();
        const phaseChangeSynth = new Tone.Synth({
            oscillator: { type: "triangle" },
            envelope: {
                attack: 0.01,
                decay: 0.2,
                sustain: 0,
                release: 0.5,
            }
        }).toDestination();
        const finalTone = new Tone.Synth({
            oscillator: { type: "square" },
            envelope: {
                attack: 0.05,
                decay: 0.8,
                sustain: 0,
                release: 1.0,
            }
        }).toDestination();

        let audioContextReady = false;
        document.body.addEventListener('click', () => {
            if (!audioContextReady) {
                Tone.start();
                audioContextReady = true;
            }
        }, { once: true });

        const playTypingSound = () => {
            typingSynth.triggerAttackRelease("C2", "8n", "+0.01");
        };

        const typeLogMessage = (message, delay, callback) => {
            let i = 0;
            const typing = setInterval(() => {
                if (i < message.length) {
                    protocolLog.textContent += message.charAt(i);
                    protocolLog.scrollTop = protocolLog.scrollHeight;
                    playTypingSound();
                    i++;
                } else {
                    clearInterval(typing);
                    protocolLog.textContent += '\n';
                    if (callback) {
                        setTimeout(callback, 500);
                    }
                }
            }, delay);
        };

        const startWipeProcess = async (files) => {
            // Reset UI
            outputSection.classList.add('hidden');
            verificationResult.classList.add('hidden');
            visualizeButton.disabled = true;
            authorizeAnnihilationButton.disabled = true;
            consentCheckbox.checked = false;
            stop3DAnimation();
            wipedDataContainer.innerHTML = '<canvas id="dataCanvas" class="w-full h-full"></canvas>';
            protocolLog.textContent = '';
            dropText.textContent = `Processing ${files.length} file(s)...`;
            dropZone.classList.add('pointer-events-none');
            dropZone.classList.add('opacity-50');
            progressBarContainer.classList.remove('hidden');

            const totalFiles = files.length;
            let filesProcessed = 0;
            const certificationData = [];

            for (const file of files) {
                const logSteps = [
                    { text: `[INIT] Activating "Parallelized Entropic Inversion (PEI) Protocol" for ${file.name}...`, progressOffset: 0, sound: null },
                    { text: `[PHASE 1] Concurrent Bit-State Inversion...`, progressOffset: 25, sound: () => phaseChangeSynth.triggerAttackRelease("E4", "8n") },
                    { text: `[TASK] Initializing 256 parallel entropic engines.`, progressOffset: 50, sound: null },
                    { text: `[RESULT] Phase 1 complete. Data-state is now in a uniform superposition.`, progressOffset: 75, sound: null },
                    { text: `[PHASE 2] Asynchronous Trivialization...`, progressOffset: 90, sound: () => phaseChangeSynth.triggerAttackRelease("G4", "8n") },
                    { text: `[TASK] Forcing informational bits to trivial, non-complex states.`, progressOffset: 95, sound: null },
                    { text: `[ALERT] Triviality coefficient is at optimal levels...`, progressOffset: 98, sound: null },
                    { text: `[RESULT] Phase 2 complete. Informational signature is fully nulled.`, progressOffset: 100, sound: () => phaseChangeSynth.triggerAttackRelease("C5", "8n") }
                ];
                
                // Simulate processing for each file sequentially for the log
                for (const step of logSteps) {
                    await new Promise(resolve => typeLogMessage(step.text, 20, resolve));
                    const progress = ((filesProcessed / totalFiles) * 100) + (step.progressOffset / totalFiles);
                    progressBar.style.width = `${progress}%`;
                    if (step.sound) step.sound();
                }

                // Simulate finalization
                await new Promise(resolve => typeLogMessage(`[RESULT] Protocol complete for ${file.name}.`, 15, resolve));
                finalTone.triggerAttackRelease("C6", "4n");

                const cert = await generateAndCertify(file);
                certificationData.push(cert);
                filesProcessed++;
            }

            protocolLog.textContent += `\n[SUMMARY] All ${totalFiles} files have been processed.\n`;
            visualizeButton.disabled = false;
            progressBarContainer.classList.add('hidden');
            
            if (certificationData.length > 0) {
                const lastCert = certificationData[certificationData.length - 1];
                certifiedFileName.textContent = lastCert.fileName;
                tokenText.textContent = lastCert.token;
                tokenInput.value = lastCert.token;
                outputSection.classList.remove('hidden');
            }
            dropText.textContent = "Protocol complete. Awaiting final purge.";
            dropZone.classList.add('cursor-not-allowed');
            dropZone.classList.remove('cursor-pointer');
        };

        const generateAndCertify = async (file) => {
            const userProvidedId = userIdDisplay.textContent;
            const certificationData = {
                fileName: file.name,
                fileSize: file.size,
                certification: `This file, "${file.name}", has been securely wiped by user ${userProvidedId}.`,
                token: crypto.randomUUID().replace(/-/g, ''),
                timestamp: new Date(),
                userId: userId
            };
            currentToken = certificationData.token;

            try {
                const certificationsCollection = collection(db, `artifacts/${appId}/public/data/certifications`);
                const docRef = await addDoc(certificationsCollection, certificationData);
                console.log("Document written with ID: ", docRef.id);
                return certificationData;
            } catch (e) {
                console.error("Error adding document: ", e);
                protocolLog.textContent += `[ERROR] Error generating certification for ${file.name}. Check console for details.\n`;
                return null;
            }
        };

        const resetApp = () => {
            protocolLog.textContent = `[STATUS] Application reset complete. Awaiting new protocol.`;
            dropZone.classList.remove('cursor-not-allowed', 'opacity-50', 'hover');
            dropZone.classList.add('cursor-pointer');
            dropText.textContent = "Drag & Drop **multiple** files here, or click to select.";
            outputSection.classList.add('hidden');
            verificationResult.classList.add('hidden');
            visualizeButton.disabled = true;
            authorizeAnnihilationButton.disabled = true;
            consentCheckbox.checked = false;
            stop3DAnimation();
            wipedDataContainer.innerHTML = '<canvas id="dataCanvas" class="w-full h-full"></canvas>';
            tokenInput.value = "";
            currentToken = null;
        };

        const stop3DAnimation = () => {
            if (is3DAnimating) {
                is3DAnimating = false;
                if (renderer) {
                    renderer.dispose();
                }
                if (scene) {
                    scene.children.forEach(child => scene.remove(child));
                }
                camera = null;
                scene = null;
                renderer = null;
            }
        };

        // Custom message box function
        const showMessage = (text) => {
            messageBox.textContent = text;
            messageBox.classList.add('show');
            setTimeout(() => {
                messageBox.classList.remove('show');
            }, 2000);
        };

        // Copy to clipboard function
        copyButton.addEventListener('click', () => {
            const tempInput = document.createElement('textarea');
            tempInput.value = tokenText.textContent;
            document.body.appendChild(tempInput);
            tempInput.select();
            document.execCommand('copy');
            document.body.removeChild(tempInput);
            showMessage("Token copied to clipboard!");
        });

        // Verification logic
        verifyButton.addEventListener('click', async () => {
            const token = tokenInput.value.trim();
            if (!token) {
                verificationResult.classList.remove('bg-green-600', 'bg-red-600');
                verificationResult.classList.add('bg-gray-600');
                verificationStatus.textContent = "Please enter a token.";
                verificationDetails.textContent = "";
                verificationResult.classList.remove('hidden');
                return;
            }

            verificationStatus.textContent = "Verifying...";
            verificationResult.classList.remove('hidden', 'bg-green-600', 'bg-red-600');
            verificationResult.classList.add('bg-gray-600');
            verificationDetails.textContent = "";

            try {
                const certificationsCollection = collection(db, `artifacts/${appId}/public/data/certifications`);
                const q = query(certificationsCollection, where("token", "==", token));
                const querySnapshot = await getDocs(q);

                if (querySnapshot.empty) {
                    verificationStatus.textContent = "Verification Failed";
                    verificationDetails.textContent = "Token not found. The data may have already been purged.";
                    verificationResult.classList.remove('bg-gray-600');
                    verificationResult.classList.add('bg-red-600');
                } else {
                    const docData = querySnapshot.docs[0].data();
                    verificationStatus.textContent = "Verification Successful!";
                    verificationDetails.innerHTML = `
                        <p class="mt-2 text-white"><strong>File:</strong> ${docData.fileName}</p>
                        <p class="text-white"><strong>Size:</strong> ${docData.fileSize} bytes</p>
                        <p class="text-white"><strong>Timestamp:</strong> ${docData.timestamp.toDate().toLocaleString()}</p>
                        <p class="text-white"><strong>User:</strong> ${docData.userId}</p>
                    `;
                    verificationResult.classList.remove('bg-gray-600');
                    verificationResult.classList.add('bg-green-600');
                }
            } catch (error) {
                console.error("Error during verification:", error);
                verificationStatus.textContent = "Verification Error";
                verificationDetails.textContent = "An error occurred. Check the console for more details.";
                verificationResult.classList.remove('bg-gray-600');
                verificationResult.classList.add('bg-red-600');
            }
        });
        
        // Consent and Purge logic
        consentCheckbox.addEventListener('change', () => {
            authorizeAnnihilationButton.disabled = !consentCheckbox.checked;
        });

        authorizeAnnihilationButton.addEventListener('click', async () => {
            protocolLog.textContent += `\n[FINISH] Initiating final data purge...\n`;
            
            try {
                const certificationsCollection = collection(db, `artifacts/${appId}/public/data/certifications`);
                const q = query(certificationsCollection, where("token", "==", currentToken));
                const querySnapshot = await getDocs(q);
                
                querySnapshot.forEach(async (doc) => {
                    await deleteDoc(doc.ref);
                    protocolLog.textContent += `[PURGE] Document ${doc.id} successfully annihilated.\n`;
                });
            } catch (error) {
                console.error("Error during purge:", error);
                protocolLog.textContent += `[ERROR] Purge failed. Check console for details.\n`;
            } finally {
                setTimeout(resetApp, 2000);
            }
        });

        // 3D Visualization Logic with three.js
        let camera, scene, renderer, particleSystem;
        let particleVelocities = [];
        let particleCount = 10000;

        const updateParticleColors = () => {
            if (!particleSystem) return;
            const colors = particleSystem.geometry.attributes.color.array;
            const color = new THREE.Color();
            for (let i = 0; i < particleCount; i++) {
                color.setHSL(0.5 + Math.random() * 0.5, 1.0, 0.5); // Blue/Green
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }
            particleSystem.geometry.attributes.color.needsUpdate = true;
        };

        const init3D = () => {
            const container = document.getElementById('wipedDataContainer');
            const canvas = document.getElementById('dataCanvas');

            if (is3DInitialized) {
                updateParticleColors();
                return;
            }

            // Dispose of previous scene if it exists
            if (renderer) renderer.dispose();
            if (scene) scene.children.forEach(child => scene.remove(child));

            // Set up scene
            scene = new THREE.Scene();

            // Set up camera
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.z = 10;

            // Set up renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000, 0);

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            // Create the central data stream
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            particleVelocities = []; 

            for (let i = 0; i < particleCount; i++) {
                // Start all particles at a central point with slight randomness
                const x = THREE.MathUtils.randFloatSpread(0.5);
                const y = THREE.MathUtils.randFloatSpread(0.5);
                const z = THREE.MathUtils.randFloatSpread(0.5);
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                // Create a random velocity vector
                const speed = 0.5 + Math.random() * 0.5;
                const velocity = new THREE.Vector3(
                    Math.random() * 2 - 1, 
                    Math.random() * 2 - 1, 
                    Math.random() * 2 - 1
                ).normalize().multiplyScalar(speed);
                particleVelocities.push(velocity);
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const streamMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            particleSystem = new THREE.Points(geometry, streamMaterial);
            scene.add(particleSystem);
            
            is3DAnimating = true;
            isExploded = false;
            is3DInitialized = true;
            updateParticleColors();
        };

        const animate3D = () => {
            if (!is3DAnimating) return;
            requestAnimationFrame(animate3D);

            if (particleSystem) {
                const positions = particleSystem.geometry.attributes.position.array;
                const colors = particleSystem.geometry.attributes.color.array;
                const totalParticles = positions.length / 3;

                if (isExploded) {
                    // Explode and fade out
                    for (let i = 0; i < totalParticles; i++) {
                        positions[i * 3] += particleVelocities[i].x;
                        positions[i * 3 + 1] += particleVelocities[i].y;
                        positions[i * 3 + 2] += particleVelocities[i].z;

                        // Decay velocity to slow down
                        particleVelocities[i].multiplyScalar(0.98);

                        // Fade the color to black
                        colors[i * 3] *= 0.98;
                        colors[i * 3 + 1] *= 0.98;
                        colors[i * 3 + 2] *= 0.98;
                    }
                } else {
                    // Swirling "data core" effect
                    for (let i = 0; i < totalParticles; i++) {
                        const t = Date.now() * 0.0005 + i;
                        positions[i * 3] += Math.sin(t) * 0.005;
                        positions[i * 3 + 1] += Math.cos(t) * 0.005;
                        positions[i * 3 + 2] = positions[i * 3 + 2] * 0.99 + Math.sin(t) * 0.001;
                    }
                }

                particleSystem.geometry.attributes.position.needsUpdate = true;
                particleSystem.geometry.attributes.color.needsUpdate = true;
            }

            // Rotate the camera for a dynamic view
            camera.position.x = Math.sin(Date.now() * 0.0001) * 8;
            camera.position.y = Math.cos(Date.now() * 0.0001) * 8;
            camera.lookAt(new THREE.Vector3(0, 0, 0));

            renderer.render(scene, camera);
        };
        
        // Handle window resizing
        window.addEventListener('resize', () => {
            const container = document.getElementById('wipedDataContainer');
            if (camera && renderer && container) {
                const width = container.clientWidth;
                const height = container.clientHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            }
        });

        // Visualization logic
        visualizeButton.addEventListener('click', () => {
            init3D();
            animate3D();
            
            // Wait a moment before the explosion
            setTimeout(() => {
                isExploded = true;
                
                // After 5 seconds, stop the animation
                setTimeout(() => {
                    stop3DAnimation();
                }, 5000);
            }, 1000);
        });

        // PDF Generation Logic
        generatePdfButton.addEventListener('click', () => {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();

            const fileName = certifiedFileName.textContent;
            const token = tokenText.textContent;
            const userProvidedId = userIdDisplay.textContent;
            const timestamp = new Date().toLocaleString();

            doc.setFontSize(22);
            doc.text("Certificate of Data Annihilation", 105, 30, { align: "center" });

            doc.setFontSize(14);
            doc.text("This document certifies that the following file has undergone the Final Data Annihilation Protocol.", 105, 50, { align: "center" });
            
            doc.line(20, 60, 190, 60);

            doc.setFontSize(12);
            doc.text("File Name:", 20, 75);
            doc.setFontSize(16);
            doc.text(fileName, 20, 85);
            
            doc.setFontSize(12);
            doc.text("Generated Token:", 20, 100);
            doc.setFontSize(16);
            doc.text(token, 20, 110);
            
            doc.setFontSize(12);
            doc.text("User ID:", 20, 125);
            doc.setFontSize(16);
            doc.text(userProvidedId, 20, 135);

            doc.setFontSize(12);
            doc.text("Date of Annihilation:", 20, 150);
            doc.setFontSize(16);
            doc.text(timestamp, 20, 160);

            doc.line(20, 175, 190, 175);

            doc.setFontSize(10);
            doc.text("This certificate is provided for informational and verification purposes only. The process is a simulation and does not physically destroy local files.", 105, 190, { align: "center" });

            doc.save("Annihilation_Certificate.pdf");
        });
        
        // Reset button functionality
        resetButton.addEventListener('click', () => {
            resetApp();
        });

        // Initialize Firebase on page load
        setupFirebase();
    </script>
</body>
</html>
